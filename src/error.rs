use std::fmt;

#[derive(Debug, PartialEq, Eq)]
#[non_exhaustive]
/// The error type of the rcgen crate
pub enum Error {
	/// The provided certificate's signature algorithm
	/// is incompatible with the given key pair
	CertificateKeyPairMismatch,
	/// The given certificate couldn't be parsed
	CouldNotParseCertificate,
	/// The given certificate signing request couldn't be parsed
	CouldNotParseCertificationRequest,
	/// The given key pair couldn't be parsed
	CouldNotParseKeyPair,
	/// Duplicate extension OID
	DuplicateExtension(String),
	/// Invalid certificate revocation list (CRL) next update.
	InvalidCrlNextUpdate,
	/// An IP address was provided as a byte array, but the byte array was an invalid length.
	InvalidIpAddressOctetLength(usize),
	/// Invalid subject alternative name type
	#[cfg(feature = "x509-parser")]
	InvalidNameType,
	/// CRL issuer specifies Key Usages that don't include cRLSign.
	IssuerNotCrlSigner,
	/// There is no support for generating
	/// keys for the given algorithm
	KeyGenerationUnavailable,
	/// Error from the pem crate
	#[cfg(feature = "pem")]
	PemError(pem::PemError),
	/// Error generated by a remote key operation
	RemoteKeyError,
	/// The `ring` library rejected the key upon loading
	RingKeyRejected(String),
	/// Unspecified `ring` error
	RingUnspecified,
	/// Time conversion related errors
	Time,
	/// Unsupported basic constraints extension path length in CSR
	#[cfg(feature = "x509-parser")]
	UnsupportedBasicConstraintsPathLen,
	/// Unsupported extension requested in CSR
	#[cfg(feature = "x509-parser")]
	UnsupportedExtension,
	/// Unsupported general name type in CSR
	#[cfg(feature = "x509-parser")]
	UnsupportedGeneralName,
	/// Unsupported field when generating a CSR
	UnsupportedInCsr,
	/// The requested signature algorithm is not supported
	UnsupportedSignatureAlgorithm,
}

impl fmt::Display for Error {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		use self::Error::*;
		match self {
			CouldNotParseCertificate => write!(f, "Could not parse certificate")?,
			CouldNotParseCertificationRequest => write!(
				f,
				"Could not parse certificate signing \
				request"
			)?,
			CouldNotParseKeyPair => write!(f, "Could not parse key pair")?,
			#[cfg(feature = "x509-parser")]
			InvalidNameType => write!(f, "Invalid subject alternative name type")?,
			InvalidIpAddressOctetLength(actual) => {
				write!(f, "Invalid IP address octet length of {actual} bytes")?
			},
			KeyGenerationUnavailable => write!(
				f,
				"There is no support for generating \
				keys for the given algorithm"
			)?,
			UnsupportedSignatureAlgorithm => write!(
				f,
				"The requested signature algorithm \
				is not supported"
			)?,
			#[cfg(feature = "x509-parser")]
			UnsupportedExtension => write!(f, "Unsupported extension requested in CSR")?,
			RingUnspecified => write!(f, "Unspecified ring error")?,
			RingKeyRejected(e) => write!(f, "Key rejected by ring: {}", e)?,
			CertificateKeyPairMismatch => write!(
				f,
				"The provided certificate's signature \
				algorithm is incompatible with the given key pair"
			)?,

			Time => write!(f, "Time error")?,
			RemoteKeyError => write!(f, "Remote key error")?,
			#[cfg(feature = "pem")]
			PemError(e) => write!(f, "PEM error: {}", e)?,
			UnsupportedInCsr => write!(f, "Certificate parameter unsupported in CSR")?,
			InvalidCrlNextUpdate => write!(f, "Invalid CRL next update parameter")?,
			IssuerNotCrlSigner => write!(
				f,
				"CRL issuer must specify no key usage, or key usage including cRLSign"
			)?,
			DuplicateExtension(oid) => {
				write!(f, "Extension with OID {oid} present multiple times")?
			},
			#[cfg(feature = "x509-parser")]
			UnsupportedBasicConstraintsPathLen => write!(
				f,
				"Unsupported basic constraints extension path length constraint in CSR"
			)?,
			#[cfg(feature = "x509-parser")]
			UnsupportedGeneralName => write!(f, "Unsupported general name in CSR",)?,
		};
		Ok(())
	}
}

impl std::error::Error for Error {}

impl From<ring::error::Unspecified> for Error {
	fn from(_unspecified: ring::error::Unspecified) -> Self {
		Error::RingUnspecified
	}
}

impl From<ring::error::KeyRejected> for Error {
	fn from(err: ring::error::KeyRejected) -> Self {
		Error::RingKeyRejected(err.to_string())
	}
}

#[cfg(feature = "pem")]
impl From<pem::PemError> for Error {
	fn from(e: pem::PemError) -> Self {
		Error::PemError(e)
	}
}
